---
title: "A Walkthrough of RiboR"
author: "Michael Geng"
output:
  html_document:
    theme: lumen
    toc: true
    toc_depth: 4
    toc_float: true
  pdf_document:
    toc: true
    toc_depth: 4
  rmarkdown:: 
    html_vignette
vignette: >
  %\VignetteIndexEntry{A Walkthrough of RiboR} 
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction 
[Ribosome profiling](https://www.nature.com/articles/nrg3645) is a sequencing based method to study protein synthesis transcriptome-wide. Actively translating mRNAs are engaged with ribosomes and protein synthesis rates can be approximated by the number of ribosomes that are translating a given mRNA. Ribosome profiling employs an RNase digestion step to recover fragments of RNA protected by ribosomes which are called Ribosome protected footprints (RPFs).

Ribosome profiling data analyses involve several quantifications for each transcript. Specifically, the RPF lengths  provide valuable biological information (see, for example, [Lareau et al.](https://elifesciences.org/articles/01257) and [Wu et al.](https://www.sciencedirect.com/science/article/pii/S1097276518310633?via%3Dihub)). To facilitate ribosome profiling data analyses as a function of RPF length in a highly efficient manner, we implemented a new data format, called ribo. Files in ribo format are called [.ribo](https://ribogadgets.readthedocs.io/en/latest/ribo_file_format.html) files.

RiboR package is an R interface for analyzing .ribo files. The package offers a suite of reading functions for .ribo files and provides plotting functions that are most often employed in ribosome profiling analyses. Using RiboR, one can import .ribo files into the R environment, read ribosome profiling data into [data tables](https://cran.r-project.org/web/packages/data.table/index.html) and generate essential plots in a few lines of R code.

This document is structured into several sections. First, we give  an overview of the Ribo File format and define transcript regions. Second, we provide installation instructions for RiboR. Third, we describe how to import a .ribo file into the R environment (Getting Started) and demonstrate essential ribosome profiling data analyses in three sections:

* Length Distribution
* Metagene Analysis
* Region Counts

In the last two sections, we then describe some advanced features including renaming transcripts using aliases, accessing .ribo file attributes, the annotation that defines transcript regions. In the last section, we explain the three optional types of data, which may exist in a .ribo file: 

* Metadata
* Coverage:  Nucleotide level coverage of each transcript.
* RNA-Seq: A ribosome profiling experiment can be paired with an RNA-Seq experiment to study ribosome occupancy together with transcript abundance.

## .ribo File Format 
.ribo files are built on an [HDF5](https://www.hdfgroup.org/solutions/hdf5/) architecture and has a predefined internal structure (Figure 1). A more detailed explanation of the ribo format is provided in a [readthedocs page](https://ribogadgets.readthedocs.io/en/latest/ribo_file_format.html).

## Installation 
The source code of RiboR package is in a [public Github repository](https://github.com/ribosomeprofiling/ribor).

### Availability 
The source code of RiboR package is available in a [public Github repository](https://github.com/ribosomeprofiling/ribor).

### General Requirements
* **R:** RiboR requires **version 3.6 or later**. Previous R versions are likely to cause installation or run time problems.

### Installing from Github
**Devtools:** Installing the package from Github requires `devtools`, a CRAN package that provides a wide suite of development tools in the R environment. 

To install the package, run the following lines of code.
```{r, eval = FALSE}
install.packages("devtools")
library("devtools")
install_github("ribosomeprofiling/ribo/ribor")
```

### Installing from Bioconductor 
To install from Bioconductor, start R (version "3.6 or later") and enter:
``` {r, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("ribor")
```

### For Linux Users 
For Linux distributions, devtools requires installation of additional dependencies. For Ubuntu-based distributions, the following command installs these dependencies.

`sudo apt-get install libxml2-dev libcurl4-openssl-dev libssl-dev -y`

## Getting Started
``` {r, eval = TRUE}
library(ribor)
```
#### Generating a .ribo object
In order to interact with the .ribo file, it is necessary to create a ribo object that provides a direct handle to the file and displays its various attributes.

```{r createRibo}
#file path to the example ribo file 
file.path <- system.file("extdata", "HEK293_ingolia.ribo", package = "ribor")

#generates the 'ribo' class object 
original.ribo <- create_ribo(file.path)
```

**Do not modify the values of the returned ribo object.**
Certain values in the `ribo` object's list are used by later functions, so manually changing these values can alter the correctness of later function calls.

Once the ribo object is created, we can then inquire about the contents of the .ribo file.

For this purpose, there is a print function for the ribo object. To view some information about the ribo file, the following will suffice, but the `print` function can also be used.

```{r}
original.ribo
```

The above output provides information about the internal contents and datasets of each individual experiment as well as general information across all experiments. Now, with the generated "ribo" object, it may be helpful to visualize and take a first glance of the data.


## Visualising Data
This package comes with the following plotting functions.
    
* `plot_length_distribution()`
* `plot_metagene()`
* `plot_region_counts()`

For each these of functions, the user has two general options for input.

* the ribo object 
* a tidy data table
  
In the case of the first option, a call to the respective reading function is made. As a result, the run times will be longer, and there is less control regarding the data input to the plot. However, upon generation of a ribo object, it may be useful to the user to get an early visual of the data.

The second option allows the user to make some changes to the data table before plotting as long as the column structure and order is preserved. Examples for this will be provided later when we retrieve the experimental data.

#### Length Distribution Plots
By directly using the ribo object, the following code will plot the length distribution from the read lengths 28 to 32, where the y-axis denotes the fraction of the count over the total reads of its respective experiment instead of the raw count.

``` {r plot_length_distribution ribo, fig.width = 7}
plot_length_distribution(x           = original.ribo,
                         region      = "CDS",
                         range.lower = 28,
                         range.upper = 32,
                         fraction    = TRUE)
```

In the above example, the y-axis values are the fraction of the reads mapping to CDS region. We can plot raw numbers by changing the argument `fraction = FALSE`.
In the example below, we plot the number of reads mapping to UTR5. 

``` {r plot_length_distribution_UTR5 ribo, fig.width = 7}
plot_length_distribution(x           = original.ribo,
                         region      = "UTR5",
                         range.lower = 28,
                         range.upper = 32,
                         fraction    = FALSE)
```


#### Metagene Plots

Using `plot_metagene`, we can plot the coverage around the start or stop sites

The following code will produce the metagene plot at the start site for the experiment
`GSM1606107`. The values on the y-axis are the raw counts.

```{r plot_metagene ribo_start, fig.width = 7}
plot_metagene(original.ribo,
              site        = "start",
              experiments = c("GSM1606107"),
              range.lower = 28,
              range.upper = 32)
```

If we don't the `experiments` parameter, all available experiments will be plotted.
To better compare these experiments, we normalize the coverage by setting 
`normalize = TRUE`. 
We can also change the default title to a different one, for example, by setting
`title = "Stop Site Coverage"`.
In the following example, in addition to these psarameters,
we set `site = "stop"` to see the stop site coverage.  

```{r plot_metagene ribo, fig.width = 7}
plot_metagene(original.ribo,
              site        = "stop",
              normalize   = TRUE,
              title       = "Stop Site Coverage",
              range.lower = 28,
              range.upper = 32)
```

#### Region Counts Bar Plots
The following code will plot the region counts of the UTR5, CDS, and UTR3 as a stacked bar plot. 

``` {r plot_region_counts ribo, fig.width = 7}
plot_region_counts(x           = original.ribo,
                   range.lower = 28,
                   range.upper = 32)
```




## Retrieving Data 

### Ribo File Format

The image below provides a visual of the internal .ribo file format and shows its internal datasets.

```{r pressure, echo=FALSE, fig.cap="Ribo File Internal Directory", out.width = '80%'}
knitr::include_graphics("ribo_file_structure.jpg")
```

Note that RNA-Seq and Coverage data are optional. 
Therefore, one must check that they are available, in .ribo file of interest,
before attempting to retrive those data.

This package provides the following reading functions for each of the data sets found in a .ribo file.

* `get_metagene()` to retrieve the metagene start or stop site coverage
* `get_tidy_metagene()` is a wrapper of `get_metagene()` and returns a tidy data table of the metagene start or stop site coverage
* `get_region_counts()` to get the counts of each transcript region (UTR5, UTR5 Junction, CDS, UTR3 Junction, UTR3)
* `get_rnaseq()` to retrieve the RNA-Seq data of a given experiment, if it exists 
* `get_coverage()` to retrieve the coverage data, if it exists, at each position of a given transcript 


### Renaming Transcripts

In some annotations or transcriptome assemblies, transcript names are very long and difficult to reference.

``` {r cumbersome}
head(get_reference_names(original.ribo))
```

As a work around, an optional parameter called `rename` can be provided when initializing a ribo object. 

There are two options for the `rename` parameter.

The first is a renaming **function**. This is often a short piece of code that parses the original name and extracts a far shorter gene name. The `ribor` package provides a default renaming function, named `rename_default` for the appris human transcriptome, but if a different transcriptome is used or a custom renaming function is desired, then it can be created and passed in with the `rename` parameter of the `create_ribo()` function.

As an example, the following function extracts the fifth entry in the transcript name, separated by "|".

```{r def_rename_default}
rename_default <- function(names){
  return(unlist(strsplit(names, split = "[|]"))[5])
}

rename_default("ENST00000335137.4|ENSG00000186092.6|OTTHUMG00000001094.4|-|OR4F5-201|OR4F5|1054|protein_coding|") 
```

Using the above function, the following code will generate a ribo object and assign an alias to all of the transcripts in a .ribo file.

``` {r alias}
alias.ribo    <- create_ribo(file.path, rename = rename_default)
alias.ribo
```

In the case that there is no simple, universal function that can extract a nickname for each of the transcripts, a second option is provide a string **vector** 
containing the alias names. The string vector should correspond to the order of reference names in the output of `get_reference_names`. A subsequent call to `set_aliases` can be used to add aliases to an already existing ribo object.

``` {r set_aliases}
#create a ribo file 
alias.ribo    <- create_ribo(file.path)

#generate the vector of aliases
aliases <- rename_transcripts(ribo = alias.ribo, rename = rename_default)

#add aliases
alias.ribo <- set_aliases(alias.ribo, aliases)

head(aliases)

alias.ribo
```

Note that `has.alias = TRUE` above.

In the following subsections, we will use this `alias.ribo` object
to retrieve data with short transcript names.

### Condensing the Output
To condense the output of the data tables, many of the reading functions below contain at least one of the following parameters.

* length
    * If TRUE, the counts will be summed up across read lengths. This means that information about the counts at each read length are lost. Otherwise, if length is FALSE, the counts at each individual read length will be preserved.
    
* transcript
    * If TRUE, the counts will be summed up across the transcript names. This means that information about the counts at each individual transcript are lost. Otherwise, if transcript is FALSE, the counts at each individual transcript will be preserved. 

### Metagene Data
There are two functions that allow the user to obtain metagene coverage data. 

* `get_metagene()`
     * This function returns a data table of metagene coverage.
     
* `get_tidy_metagene()`
     * This function returns a tidy data table of metagene coverage. It is a wrapper of the `get_metagene()` function, and in order to keep manageable data table dimensions, it will always sum across the transcripts.

Starting off with the smallest return value, use `length = TRUE` and `transcript = TRUE` to sum the data for each experiment across all read lengths and transcripts. As a result, one row of values will exist for each experiment.
```{r}
#get the start site across read lengths 28 to 32
meta.start <- get_metagene(ribo.object = alias.ribo, 
                           site        = "start",
                           range.lower = 28,
                           range.upper = 32,
                           length      = TRUE,
                           transcript  = TRUE)
#only print first ten columns 
print(meta.start[ , 1:10])
```

To obtain the tidy version of the above data table,

```{r}
tidy.meta.start <- get_tidy_metagene(ribo.object = alias.ribo,
                                     site        = "start",
                                     range.lower = 28,
                                     range.upper = 32,
                                     length      = TRUE)
head(tidy.meta.start)
```

To maintain the counts at each individual read length but NOT at each transcript, 
use `length = FALSE` and `transcript = TRUE`.
If the metagene data of a single read length, say 30, is needed,
set `range.lower` and `range.upper` to 30. 
By default, data retrieval functions return data from all available experiments.
To obtain data from a particular subset of experiments, 
provide a list of experiment names in the `experiments` parameter. 

```{r}
meta.start <- get_metagene(ribo.object = alias.ribo, 
                           site        = "start",
                           range.lower = 30,
                           range.upper = 30,
                           experiments = c("GSM1606108"),
                           length      = FALSE,
                           transcript  = TRUE)

print(meta.start[, 1:10])
```

Now, to preserve the counts at each individual transcript but also sum across the read lengths, we set `transcript = FALSE` and `length = TRUE`.

```{r}
meta.start <- get_metagene(ribo.object = alias.ribo, 
                           site        = "start",
                           range.lower = 28,
                           range.upper = 32,
                           length      = TRUE,
                           transcript  = FALSE,
                           alias       = TRUE)

print(meta.start[1:10, 1:10])
```

Lastly, to preserve information about the counts at each individual read length and at each individual transcript, use `transcript = FALSE` and `length = FALSE`. Because there are often thousands of transcripts, this is usually the most computationally cumbersome option in the retrieval of the metagene data. The raw data set is read in and no summation operations are performed. **For actual data sets, run times will be slow for this option, and running the function with these options requires a substantial amount of memory.**
```{r}
meta.start <- get_metagene(ribo.object = alias.ribo, 
                           site        = "start",
                           range.lower = 28,
                           range.upper = 32,
                           length      = FALSE,
                           transcript  = FALSE,
                           alias       = TRUE)

#print first ten columns and first ten rows
print(meta.start[1:10, 1:10])
```


### Region Counts 
Similar to the `get_metagene()` function, the `get_region_counts()` function has the `transcript` and `length` parameters. 

As previously mentioned, `transcript` specifies whether or not to sum across the transcripts, and `length` specifies whether or not to sum across the read lengths. 

To get the region counts summed across both lengths and transcripts, set `length = TRUE` and `transcript = TRUE`.

``` {r get_region_counts default}
rc <- get_region_counts(original.ribo,
                        range.lower = 28,
                        range.upper = 32,
                        length      = TRUE,
                        transcript  = TRUE,
                        region      = c("CDS"))
rc
```

To get the data only summed across transcripts, then set `length = FALSE` and `transcript = TRUE`.

``` {r get_region_counts length}
rc <- get_region_counts(original.ribo,
                        range.lower = 28,
                        range.upper = 32,
                        length      = FALSE,
                        transcript  = TRUE,
                        region      = c("CDS"))
rc
```

Now, when presented with the option of preserving the region counts at each individual read length, it may be wise to present the transcript names as their shortened aliases.

To get the data only summed across the read lengths, set `length = TRUE` and `transcript = FALSE`. Note that the `alias = TRUE` in this case, and instead of `original.ribo`, we are using `alias.ribo`.

``` {r get_region_counts transcript}
rc <- get_region_counts(alias.ribo,
                        range.lower = 28,
                        range.upper = 32,
                        length      = TRUE,
                        transcript  = FALSE,
                        alias       = TRUE,
                        region      = c("CDS"))
rc
```

To get the data in its full form, preserving the information each individual read length and transcript, set `length = FALSE` and `transcript = FALSE`.

``` {r get_region_counts full}
rc <- get_region_counts(alias.ribo,
                        range.lower = 28,
                        range.upper = 32,
                        length      = FALSE,
                        transcript  = FALSE,
                        alias       = TRUE,
                        region      = c("CDS"))
rc
```

By default, the data.tables are tidy. If a condensed, non-tidy data set is desired, then set `tidy = FALSE`.

``` {r get_region_counts non-tidy}
rc <- get_region_counts(original.ribo,
                        range.lower = 28,
                        range.upper = 32,
                        tidy        = FALSE)
rc
```

Finally, by default, the counts are not normalized, but there is an option to normalize the region counts. Set `normalize = TRUE` to instead obtain the normalized counts per million reads.

``` {r get_region_counts normalize}
rc <- get_region_counts(original.ribo,
                        range.lower = 28,
                        range.upper = 32,
                        normalize   = TRUE,
                        region      = c("CDS"))
rc
```


### Coverage Data 
Within a .ribo file, the coverage data is typically the largest dataset in terms of storage, and it accounts for a substantial portion of a .ribo file's size, when present. Because of the size, the `get_coverage()` function returns coverage information for one specific transcript at a time but for any subset of experiments. 

Note that coverage data is an optional field of ribo files.
In other words, not every experiment has coverage data necessarily.
Therefore, it is helpful to keep track of the experiment names with coverage data. Once the list is obtained, the experiments of interest can easily be subsetted and extracted.

``` {r}
#get a list of experiments that have coverage data
experiment.info <- get_info(ribo.object = alias.ribo)[['experiment.info']]
has.coverage <- experiment.info[experiment.info$coverage == TRUE, experiment]
has.coverage
```

Because `get_coverage` takes the transcript name, for annotations with long transcriptome names, it is **recommended** to use aliases and generate a ribo object with a valid `rename` parameter.`

The `get_coverage()` function retrieves the coverage across any subset of the experiments that have the data set.

Please take note of the `length` parameter. If length is TRUE, then the coverage counts are summed up across the read lengths, losing information about the counts at each individual read length.

```{r}
cov <- get_coverage(ribo.object = alias.ribo,
                    name        = "MYC-206",
                    range.lower = 28,
                    range.upper = 32,
                    length      = TRUE,
                    alias       = TRUE,
                    tidy        = TRUE,
                    experiments = has.coverage)
cov[380:390]
```

To preserve the information at read length, set `length = FALSE`.
```{r}
#only using one experiment for this 
exp.names <- has.coverage[1]

#length is FALSE, get coverage information
#at each read length
cov <- get_coverage(ribo.object = alias.ribo,
                    name        = "MYC-206",
                    range.lower = 28,
                    range.upper = 32,
                    length      = FALSE,
                    alias       = TRUE,
                    tidy        = TRUE,
                    experiments = exp.names)

cov
```

If the `rename` parameter is not used in the generation of a `ribo` object, then the alternative can be bulky and inconvenient to use.

``` {r get_coverage}
transcript <- "ENST00000613283.2|ENSG00000136997.17|OTTHUMG00000128475.8|-|MYC-206|MYC|1365|protein_coding|"
cov <- get_coverage(ribo.object = original.ribo,
                    name        = transcript,
                    range.lower = 28,
                    range.upper = 32,
                    length      = FALSE,
                    tidy        = TRUE,
                    experiments = exp.names)
cov
```


### RNA-Seq Data 
The RNA-Seq data sets contain information on the relative abundance of each transcript at each of the following transcript regions.

* 5' Untranslated Region (UTR5)
* 5' Untranslated Region Junction (UTR5J)
* Coding Sequence (CDS)
* 3' Untranslated Region Junction (UTR3J)
* 3' Untranslated Region (UTR3)

To get started, it might be helpful to store a character vector of the experiment names with RNA-Seq data.

``` {r}
#get a list of experiments that have RNA-Seq data
experiment.info <- get_info(ribo.object = original.ribo)[['experiment.info']]
has.rnaseq <- experiment.info[experiment.info$rna.seq == TRUE, experiment]
has.rnaseq
```

To get all of the RNA-Seq data in the sample .ribo file in a non-tidy format, type the following.  

``` {r}
#get a list of experiments that have RNA-Seq data
rnaseq <- get_rnaseq(ribo.object = alias.ribo,
                     tidy        = FALSE,
                     alias       = TRUE,
                     experiments = has.rnaseq)

#print out the first ten columns and first ten rows 
head(rnaseq)
```

To get the the RNA-Seq data of just the experiment at just the `UTR5J`, `CDS`, and `UTR3J` regions in a tidy format, set `regions = c("UTR5J", "CDS", "UTR3J")` and `tidy = TRUE`.

```{r}
experiment <- has.rnaseq[1]
rnaseq <- get_rnaseq(ribo.object = alias.ribo,
                     tidy        = TRUE,
                     alias       = TRUE,
                     regions     = c("UTR5J", "CDS", "UTR3J"),
                     experiments = experiment)
head(rnaseq)
```

## Retrieving General Information
The `ribor` package comes with functionality to inquire about the information stored in a .ribo file. 

#### Experiment Names
At times, experiment names may be long and difficult to remember, so we may want to keep a vector of the experiment names. This will allow the user to reference an experiment by its index in a vector and allow for easier subsetting in later function calls. 
```{r get_experiments}
exp <- get_experiments(original.ribo)
exp
```

#### File Attributes
If we want a returned list of many of the previously printed attributes, then the function `get_info()` will return all of the attributes found in the root of the .ribo file as well as information on each of the experiments. 

Again, to clarify, this just returns a named list of many of the `ribo` object contents. The returned list organizes the information into three separate values, has.metadata, attributes, and experiment.info. This is a better alternative to simply referencing the values in the `ribo` object since the method reads directly from the .ribo file handle and not the downstream declared `ribo` object.

```{r get_info}
#retrieves the experiments
original.info <- get_info(ribo.object = original.ribo)
original.info
```

#### Metadata
Additionally, if we want to see the metadata of a given experiment, then we can use the `get_metadata()` function and specify the experiment of interest. The `get_metadata()` function has a print parameter and an optional name parameter to specify the experiment name.

To view the metadata of the root ribo file, consider the following.

```{r get_metadata file, eval = FALSE}
get_metadata(ribo.object = original.ribo, 
             print = TRUE)
#The output for this is quite long, so here is a truncated version.
```

```{r get_metadata shortened_meta, echo = FALSE}
info <- capture.output(get_metadata(ribo.object = original.ribo, 
                                    print = TRUE))
cat(info[1:15], sep = "\n")
```

To first find the experiments that have metadata and subsequently retrieve it from one of the experiments, consider the following.

```{r get_metadata has.metadata}
#obtain a list of experiments with metadata 
experiment.info <- get_info(ribo.object = original.ribo)[['experiment.info']]
has.metadata <- experiment.info[experiment.info$metadata == TRUE, experiment]
has.metadata
```

```{r get_metadata}
#store the name of the first experiment with metadata and gets its metadata
experiment <- has.metadata[1]

get_metadata(ribo.object = original.ribo,
             name        = experiment,
             print       = TRUE)

```


## Plots from a Data Table  
In the earlier examples of visualizing data, the ribo object was given as input to the plotting functions. This provides a convenient and low barrier of entry to visualizing the data, and it allows for a quick first glance of the data.

In the examples below, the returned data tables of the reader functions are used as input to the plotting functions.

In the case that the user wants to generate custom plots with different layers, formats, or mappings, these same data tables can often be readily used as input because of their tidy nature.

#### Metagene Plots

The following code will plot the metagene stop site by passing in a data table. The data table must be of the same structure as the returned data table from `get_tidy_metagene()`.

``` {r plot_metagene dt, fig.width = 7} 
stop.dt <- get_tidy_metagene(ribo.object = original.ribo,
                             site        = "stop",
                             range.lower = 28,
                             range.upper = 32)

plot_metagene(stop.dt)
```

To normalize the metagene data, simply set `normalize = TRUE`.

``` {r plot_metagene normalized, fig.width = 7} 
plot_metagene(stop.dt, normalize = TRUE)
```


#### Length Distribution Plots 

By first getting a data table of output from `get_length_distribution()`, the following code will generate the read length distribution.

``` {r plot_length_distribution dt, fig.width = 7}
rc.info <- get_length_distribution(ribo.object = original.ribo,
                                   region      = "CDS",
                                   range.lower = 28,
                                   range.upper = 32)

# further data table manipulation and filtering can ensue here 
# before calling the plot function

plot_length_distribution(rc.info, fraction = TRUE)
```

To plot the counts instead of fractions, the following code will work.

``` {r plot_length_distribution dt normalized, fig.width = 7}
#change the fraction parameter to FALSE 
plot_length_distribution(rc.info, fraction = FALSE)
```

#### Region Counts Bar Plots

By setting `x` to a data table obtained from the `get_region_counts()` function, the following will plot the region counts.

``` {r plot_region_counts dt, fig.width = 7}
rc.info <- get_region_counts(ribo.object = original.ribo,
                             region      = c("UTR5", "CDS", "UTR3"),
                             range.lower = 28,
                             range.upper = 32)

# further data table manipulation and filtering can ensue here 
# before calling the plot function 

plot_region_counts(rc.info)
```
